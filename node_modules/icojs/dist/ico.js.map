{"version":3,"file":"ico.js","sources":["../src/mime.js","../src/browser/image.js","../node_modules/to-data-view/index.js","../src/is-ico.js","../node_modules/decode-bmp/index.js","../node_modules/decode-ico/index.js","../src/parse/index.js","../src/browser/index.js"],"sourcesContent":["'use strict';\n\nconst MIME_BMP = 'image/bmp';\nconst MIME_JPEG = 'image/jpeg';\nconst MIME_PNG = 'image/png';\n\nmodule.exports = {\n  MIME_BMP,\n  MIME_JPEG,\n  MIME_PNG\n};\n\n","'use strict';\n\nconst { MIME_PNG } = require('../mime');\n\nconst dataURLToArrayBuffer = dataURL => {\n  const string = atob(dataURL.replace(/.+,/u, ''));\n  const view = new Uint8Array(string.length);\n  for (let i = 0; i < string.length; i++) {\n    view[i] = string.charCodeAt(i);\n  }\n  return view.buffer;\n};\n\nconst Image = {\n  /**\n   * Create imageData from image.\n   *\n   * @access private\n   * @param {ArrayBuffer} arrayBuffer - Image buffer.\n   * @returns {ImageData} ImageData.\n   */\n  decode (arrayBuffer) {\n    return new Promise(resolve => {\n      // eslint-disable-next-line node/no-unsupported-features/node-builtins\n      const url = URL.createObjectURL(new Blob([arrayBuffer]));\n      const img = document.createElement('img');\n      img.src = url;\n      img.onload = () => {\n        const { naturalHeight: height, naturalWidth: width } = img;\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(img, 0, 0);\n        const { data } = ctx.getImageData(0, 0, width, height);\n        resolve({\n          data,\n          height,\n          width\n        });\n      };\n    });\n  },\n  /**\n   * Create image from imgData.data.\n   *\n   * @access private\n   * @param {object} image - Data.\n   * @param {number} image.width - Image width.\n   * @param {number} image.height - Image height.\n   * @param {Uint8ClampedArray} image.data - Same as imageData.data.\n   * @param {string} [mime=image/png] - MIME type.\n   * @returns {ArrayBuffer} Image.\n   */\n  encode (image, mime = MIME_PNG) {\n    return new Promise(resolve => {\n      const { data, height, width } = image;\n      const canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      const ctx = canvas.getContext('2d');\n      const imageData = ctx.createImageData(width, height);\n      const dataData = imageData.data;\n      for (let i = 0; i < dataData.length; i++) {\n        dataData[i] = data[i];\n      }\n      ctx.putImageData(imageData, 0, 0);\n      resolve(dataURLToArrayBuffer(canvas.toDataURL(mime)));\n    });\n  }\n};\n\nmodule.exports = Image;\n","module.exports = function toDataView (data) {\n  if (data instanceof Uint8Array) {\n    return new DataView(data.buffer, data.byteOffset, data.byteLength)\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return new DataView(data)\n  }\n\n  throw new TypeError('Expected `data` to be an ArrayBuffer or Uint8Array')\n}\n","'use strict';\n\nconst toDataView = require('to-data-view');\n\n/**\n * Check the ArrayBuffer is valid ICO.\n *\n * @alias module:ICO\n * @param {ArrayBuffer|Buffer} source - ICO file data.\n * @returns {boolean} True if arg is ICO.\n */\nconst isICO = source => {\n  const dataView = toDataView(source);\n  return dataView.getUint16(0, true) === 0 && dataView.getUint16(2, true) === 1;\n};\n\nmodule.exports = isICO;\n","const toDataView = require('to-data-view')\n\nfunction makeDivisibleByFour (input) {\n  const rest = input % 4\n\n  return rest ? input + 4 - rest : input\n}\n\nclass Bitmap {\n  constructor (data, offset, { width, height, colorDepth, format }) {\n    this.format = format\n    this.offset = offset\n    this.depth = colorDepth\n    this.stride = makeDivisibleByFour(width * this.depth / 8)\n    this.size = (this.stride * height)\n    this.data = data.slice(this.offset, this.offset + this.size)\n\n    if (this.size !== this.data.byteLength) {\n      throw new Error('Truncated bitmap data')\n    }\n  }\n\n  get (x, y, channel) {\n    const idx = this.format.indexOf(channel)\n\n    if (this.depth === 1) {\n      const slice = this.data[(y * this.stride) + (x / 8 | 0)]\n      const mask = 1 << (7 - (x % 8) * 1)\n\n      return (slice & mask) >> (7 - (x % 8) * 1)\n    }\n\n    if (this.depth === 2) {\n      const slice = this.data[(y * this.stride) + (x / 4 | 0)]\n      const mask = 3 << (6 - (x % 4) * 2)\n\n      return (slice & mask) >>> (6 - (x % 4) * 2)\n    }\n\n    if (this.depth === 4) {\n      const slice = this.data[(y * this.stride) + (x / 2 | 0)]\n      const mask = 15 << (4 - (x % 2) * 4)\n\n      return (slice & mask) >>> (4 - (x % 2) * 4)\n    }\n\n    return this.data[(y * this.stride) + (x * (this.depth / 8)) + idx]\n  }\n}\n\nfunction decodeTrueColorBmp (data, { width, height, colorDepth, icon }) {\n  if (colorDepth !== 32 && colorDepth !== 24) {\n    throw new Error(`A color depth of ${colorDepth} is not supported`)\n  }\n\n  const xor = new Bitmap(data, 0, { width, height, colorDepth, format: 'BGRA' })\n  const and = (colorDepth === 24 && icon)\n    ? new Bitmap(data, xor.offset + xor.size, { width, height, colorDepth: 1, format: 'A' })\n    : null\n\n  const result = new Uint8Array(width * height * 4)\n\n  let idx = 0\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      result[idx++] = xor.get(x, height - y - 1, 'R')\n      result[idx++] = xor.get(x, height - y - 1, 'G')\n      result[idx++] = xor.get(x, height - y - 1, 'B')\n\n      if (colorDepth === 32) {\n        result[idx++] = xor.get(x, height - y - 1, 'A')\n      } else {\n        result[idx++] = and && and.get(x, height - y - 1, 'A') ? 0 : 255\n      }\n    }\n  }\n\n  return result\n}\n\nfunction decodePaletteBmp (data, { width, height, colorDepth, colorCount, icon }) {\n  if (colorDepth !== 8 && colorDepth !== 4 && colorDepth !== 2 && colorDepth !== 1) {\n    throw new Error(`A color depth of ${colorDepth} is not supported`)\n  }\n\n  const colors = new Bitmap(data, 0, { width: colorCount, height: 1, colorDepth: 32, format: 'BGRA' })\n  const xor = new Bitmap(data, colors.offset + colors.size, { width, height, colorDepth, format: 'C' })\n  const and = icon ? new Bitmap(data, xor.offset + xor.size, { width, height, colorDepth: 1, format: 'A' }) : null\n\n  const result = new Uint8Array(width * height * 4)\n\n  let idx = 0\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const colorIndex = xor.get(x, height - y - 1, 'C')\n\n      result[idx++] = colors.get(colorIndex, 0, 'R')\n      result[idx++] = colors.get(colorIndex, 0, 'G')\n      result[idx++] = colors.get(colorIndex, 0, 'B')\n      result[idx++] = and && and.get(x, height - y - 1, 'A') ? 0 : 255\n    }\n  }\n\n  return result\n}\n\nfunction checkMagicBytes (bytes) {\n  if (bytes !== 0x4D42) throw new Error(`Invalid magic byte 0x${bytes.toString(16)}`)\n}\n\nmodule.exports = function decodeBmp (source, { width: iconWidth = 0, height: iconHeight = 0, icon = false } = {}) {\n  const data = toDataView(source)\n\n  let headerSize\n  let bitmapWidth\n  let bitmapHeight\n  let colorDepth\n  let colorCount\n\n  if (icon) {\n    headerSize = data.getUint32(0, true)\n    bitmapWidth = (data.getUint32(4, true) / 1) | 0\n    bitmapHeight = (data.getUint32(8, true) / 2) | 0\n    colorDepth = data.getUint16(14, true)\n    colorCount = data.getUint32(32, true)\n  } else {\n    checkMagicBytes(data.getUint16(0, true))\n    headerSize = 14 + data.getUint32(14, true)\n    bitmapWidth = data.getUint32(18, true)\n    bitmapHeight = data.getUint32(22, true)\n    colorDepth = data.getUint16(28, true)\n    colorCount = data.getUint32(46, true)\n  }\n\n  if (colorCount === 0 && colorDepth <= 8) {\n    colorCount = (1 << colorDepth)\n  }\n\n  const width = (bitmapWidth === 0 ? iconWidth : bitmapWidth)\n  const height = (bitmapHeight === 0 ? iconHeight : bitmapHeight)\n\n  const bitmapData = new Uint8Array(data.buffer, data.byteOffset + headerSize, data.byteLength - headerSize)\n\n  const result = colorCount\n    ? decodePaletteBmp(bitmapData, { width, height, colorDepth, colorCount, icon })\n    : decodeTrueColorBmp(bitmapData, { width, height, colorDepth, icon })\n\n  return { width, height, data: result, colorDepth }\n}\n","const toDataView = require('to-data-view')\nconst decodeBmp = require('decode-bmp')\n\nfunction isPng (view, offset) {\n  return (view.getUint32(offset + 0) === 0x89504e47 && view.getUint32(offset + 4) === 0x0d0a1a0a)\n}\n\nfunction pngBitsPerPixel (view, offset) {\n  const bitDepth = view.getUint8(offset + 24)\n  const colorType = view.getUint8(offset + 25)\n\n  if (colorType === 0) return bitDepth * 1\n  if (colorType === 2) return bitDepth * 3\n  if (colorType === 3) return bitDepth * 1\n  if (colorType === 4) return bitDepth * 2\n  if (colorType === 6) return bitDepth * 4\n\n  throw new Error('Invalid PNG colorType')\n}\n\nfunction pngWidth (view, offset) {\n  return view.getUint32(offset + 16, false)\n}\n\nfunction pngHeight (view, offset) {\n  return view.getUint32(offset + 20, false)\n}\n\nmodule.exports = function decodeIco (input) {\n  const view = toDataView(input)\n\n  if (view.byteLength < 6) {\n    throw new Error('Truncated header')\n  }\n\n  if (view.getUint16(0, true) !== 0) {\n    throw new Error('Invalid magic bytes')\n  }\n\n  const type = view.getUint16(2, true)\n\n  if (type !== 1 && type !== 2) {\n    throw new Error('Invalid image type')\n  }\n\n  const length = view.getUint16(4, true)\n\n  if (view.byteLength < 6 + (16 * length)) {\n    throw new Error('Truncated image list')\n  }\n\n  return Array.from({ length }, (_, idx) => {\n    const width = view.getUint8(6 + (16 * idx) + 0)\n    const height = view.getUint8(6 + (16 * idx) + 1)\n    const size = view.getUint32(6 + (16 * idx) + 8, true)\n    const offset = view.getUint32(6 + (16 * idx) + 12, true)\n\n    const hotspot = (type !== 2 ? null : {\n      x: view.getUint16(6 + (16 * idx) + 4, true),\n      y: view.getUint16(6 + (16 * idx) + 6, true)\n    })\n\n    if (isPng(view, offset)) {\n      return {\n        bpp: pngBitsPerPixel(view, offset),\n        data: new Uint8Array(view.buffer, view.byteOffset + offset, size),\n        height: pngHeight(view, offset),\n        hotspot,\n        type: 'png',\n        width: pngWidth(view, offset)\n      }\n    }\n\n    const data = new Uint8Array(view.buffer, view.byteOffset + offset, size)\n    const bmp = decodeBmp(data, { width, height, icon: true })\n\n    return {\n      bpp: bmp.colorDepth,\n      data: bmp.data,\n      height: bmp.height,\n      hotspot,\n      type: 'bmp',\n      width: bmp.width\n    }\n  })\n}\n","'use strict';\n\nconst decodeIco = require('decode-ico');\nconst { MIME_PNG } = require('../mime');\n\n/**\n * @typedef {object} ParsedImage\n * @property {number} width Image width.\n * @property {number} height Image height.\n * @property {number} bpp Image color depth as bits per pixel.\n * @property {ArrayBuffer} buffer Image buffer.\n */\n\n/**\n * Parse ICO and return some image object.\n *\n * @access private\n * @param {ArrayBuffer|Buffer} data - ICO file data.\n * @param {string} mime - MIME type for output.\n * @param {object} Image - Image encoder/decoder.\n * @returns {Promise<ParsedImage[]>} Resolves to an array of {@link ParsedImage}.\n */\nconst parse = async (data, mime, Image) => {\n  const icons = decodeIco(data);\n\n  const transcodeImage = async icon => {\n    if (mime === MIME_PNG && icon.type === 'png') {\n      return Object.assign({ buffer: icon.data.buffer.slice(icon.data.byteOffset, icon.data.byteOffset + icon.data.byteLength) }, icon);\n    }\n\n    if (icon.type === 'png') {\n      const decoded = await Image.decode(icon.data);\n      Object.assign(icon, {\n        data: decoded.data,\n        type: 'bmp'\n      });\n    }\n\n    return Object.assign(icon, {\n      buffer: await Image.encode(icon, mime),\n      type: mime.replace('image/', '')\n    });\n  };\n\n  const parsedImages = await Promise.all(icons.map(transcodeImage));\n  return parsedImages;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst Image = require('./image');\nconst isICO = require('../is-ico');\nconst parseICO = require('../parse');\nconst { MIME_PNG } = require('../mime');\n\nconst parse = (arrayBuffer, mime = MIME_PNG) => parseICO(arrayBuffer, mime, Image);\n\nconst ICO = {\n  isICO,\n  parse\n};\n\nmodule.exports = ICO;\n"],"names":["MIME_PNG","require$$0","dataURLToArrayBuffer","dataURL","string","atob","replace","view","Uint8Array","length","i","charCodeAt","buffer","decode","arrayBuffer","Promise","resolve","url","URL","createObjectURL","Blob","img","document","createElement","src","onload","height","naturalHeight","width","naturalWidth","canvas","ctx","getContext","drawImage","data","getImageData","encode","image","mime","imageData","createImageData","dataData","putImageData","toDataURL","DataView","byteOffset","byteLength","ArrayBuffer","TypeError","source","dataView","toDataView","getUint16","Bitmap","offset","input","rest","colorDepth","format","depth","stride","this","size","slice","Error","x","y","channel","idx","indexOf","decodeTrueColorBmp","icon","xor","and","result","get","decodePaletteBmp","colorCount","colors","colorIndex","checkMagicBytes","bytes","toString","pngBitsPerPixel","bitDepth","getUint8","colorType","pngWidth","getUint32","pngHeight","type","Array","from","_","hotspot","isPng","bpp","bmp","headerSize","bitmapWidth","bitmapHeight","iconWidth","iconHeight","bitmapData","decodeBmp","Image","icons","decodeIco","transcodeImage","Object","assign","decoded","all","map","isICO","parse","parseICO"],"mappings":";;;;;iQAEA,MAEiB,YCFTA,EAAaC,EAEfC,EAAuB,SAAAC,WACrBC,EAASC,KAAKF,EAAQG,QAAQ,mKAAQ,KACtCC,EAAO,IAAIC,WAAWJ,EAAOK,QAC1BC,EAAI,EAAGA,EAAIN,EAAOK,OAAQC,IACjCH,EAAKG,GAAKN,EAAOO,WAAWD,UAEvBH,EAAKK,UAGA,CAQZC,gBAAQC,UACC,IAAIC,QAAQ,SAAAC,OAEXC,EAAMC,IAAIC,gBAAgB,IAAIC,KAAK,CAACN,KACpCO,EAAMC,SAASC,cAAc,OACnCF,EAAIG,IAAMP,EACVI,EAAII,OAAS,eACYC,EAAgCL,EAA/CM,cAAqCC,EAAUP,EAAxBQ,aACzBC,EAASR,SAASC,cAAc,UACtCO,EAAOF,MAAQA,EACfE,EAAOJ,OAASA,MACVK,EAAMD,EAAOE,WAAW,MAC9BD,EAAIE,UAAUZ,EAAK,EAAG,OACda,EAASH,EAAII,aAAa,EAAG,EAAGP,EAAOF,GAAvCQ,KACRlB,EAAQ,CACNkB,KAAAA,EACAR,OAAAA,EACAE,MAAAA,QAgBRQ,gBAAQC,OAAOC,yDAAOtC,SACb,IAAIe,QAAQ,SAAAC,OACTkB,EAAwBG,EAAxBH,KAAMR,EAAkBW,EAAlBX,OAAQE,EAAUS,EAAVT,MAChBE,EAASR,SAASC,cAAc,UACtCO,EAAOF,MAAQA,EACfE,EAAOJ,OAASA,UACVK,EAAMD,EAAOE,WAAW,MACxBO,EAAYR,EAAIS,gBAAgBZ,EAAOF,GACvCe,EAAWF,EAAUL,KAClBxB,EAAI,EAAGA,EAAI+B,EAAShC,OAAQC,IACnC+B,EAAS/B,GAAKwB,EAAKxB,GAErBqB,EAAIW,aAAaH,EAAW,EAAG,GAC/BvB,EAAQd,EAAqB4B,EAAOa,UAAUL,WCnEnC,SAAqBJ,MAChCA,aAAgB1B,kBACX,IAAIoC,SAASV,EAAKtB,OAAQsB,EAAKW,WAAYX,EAAKY,eAGrDZ,aAAgBa,mBACX,IAAIH,SAASV,SAGhB,IAAIc,UAAU,yDCER,SAAAC,OACNC,EAAWC,EAAWF,UACW,IAAhCC,EAASE,UAAU,GAAG,IAA+C,IAAhCF,EAASE,UAAU,GAAG,8KCL9DC,wBACSnB,EAAMoB,SAPSC,EACtBC,EAMuB5B,IAAAA,MAAOF,IAAAA,OAAQ+B,IAAAA,WAAYC,IAAAA,oHACjDA,OAASA,OACTJ,OAASA,OACTK,MAAQF,OACRG,QAXqBL,EAWQ3B,EAAQiC,KAAKF,MAAQ,GAVnDH,EAAOD,EAAQ,GAEPA,EAAQ,EAAIC,EAAOD,QAS1BO,KAAQD,KAAKD,OAASlC,OACtBQ,KAAOA,EAAK6B,MAAMF,KAAKP,OAAQO,KAAKP,OAASO,KAAKC,MAEnDD,KAAKC,OAASD,KAAK3B,KAAKY,iBACpB,IAAIkB,MAAM,4EAIfC,EAAGC,EAAGC,OACHC,EAAMP,KAAKH,OAAOW,QAAQF,UAEb,IAAfN,KAAKF,OACOE,KAAK3B,KAAMgC,EAAIL,KAAKD,QAAWK,EAAI,EAAI,IACxC,GAAM,EAAKA,EAAI,EAAK,IAEP,EAAKA,EAAI,EAAK,EAGvB,IAAfJ,KAAKF,OACOE,KAAK3B,KAAMgC,EAAIL,KAAKD,QAAWK,EAAI,EAAI,IACxC,GAAM,EAAKA,EAAI,EAAK,KAEN,EAAKA,EAAI,EAAK,EAGxB,IAAfJ,KAAKF,OACOE,KAAK3B,KAAMgC,EAAIL,KAAKD,QAAWK,EAAI,EAAI,IACxC,IAAO,EAAKA,EAAI,EAAK,KAEP,EAAKA,EAAI,EAAK,EAGpCJ,KAAK3B,KAAMgC,EAAIL,KAAKD,OAAWK,GAAKJ,KAAKF,MAAQ,GAAMS,wCAIlE,SAASE,EAAoBpC,SAAQN,IAAAA,MAAOF,IAAAA,OAAQ+B,IAAAA,WAAYc,IAAAA,QAC3C,KAAfd,GAAoC,KAAfA,QACjB,IAAIO,iCAA0BP,gCAGhCe,EAAM,IAAInB,EAAOnB,EAAM,EAAG,CAAEN,MAAAA,EAAOF,OAAAA,EAAQ+B,WAAAA,EAAYC,OAAQ,SAC/De,EAAsB,KAAfhB,GAAqBc,EAC9B,IAAIlB,EAAOnB,EAAMsC,EAAIlB,OAASkB,EAAIV,KAAM,CAAElC,MAAAA,EAAOF,OAAAA,EAAQ+B,WAAY,EAAGC,OAAQ,MAChF,KAEEgB,EAAS,IAAIlE,WAAWoB,EAAQF,EAAS,GAE3C0C,EAAM,EACDF,EAAI,EAAGA,EAAIxC,EAAQwC,QACrB,IAAID,EAAI,EAAGA,EAAIrC,EAAOqC,IACzBS,EAAON,KAASI,EAAIG,IAAIV,EAAGvC,EAASwC,EAAI,EAAG,KAC3CQ,EAAON,KAASI,EAAIG,IAAIV,EAAGvC,EAASwC,EAAI,EAAG,KAC3CQ,EAAON,KAASI,EAAIG,IAAIV,EAAGvC,EAASwC,EAAI,EAAG,KAGzCQ,EAAON,KADU,KAAfX,EACce,EAAIG,IAAIV,EAAGvC,EAASwC,EAAI,EAAG,KAE3BO,GAAOA,EAAIE,IAAIV,EAAGvC,EAASwC,EAAI,EAAG,KAAO,EAAI,WAK5DQ,EAGT,SAASE,EAAkB1C,SAAQN,IAAAA,MAAOF,IAAAA,OAAQ+B,IAAAA,WAAYoB,IAAAA,WAAYN,IAAAA,QACrD,IAAfd,GAAmC,IAAfA,GAAmC,IAAfA,GAAmC,IAAfA,QACxD,IAAIO,iCAA0BP,gCAGhCqB,EAAS,IAAIzB,EAAOnB,EAAM,EAAG,CAAEN,MAAOiD,EAAYnD,OAAQ,EAAG+B,WAAY,GAAIC,OAAQ,SACrFc,EAAM,IAAInB,EAAOnB,EAAM4C,EAAOxB,OAASwB,EAAOhB,KAAM,CAAElC,MAAAA,EAAOF,OAAAA,EAAQ+B,WAAAA,EAAYC,OAAQ,MACzFe,EAAMF,EAAO,IAAIlB,EAAOnB,EAAMsC,EAAIlB,OAASkB,EAAIV,KAAM,CAAElC,MAAAA,EAAOF,OAAAA,EAAQ+B,WAAY,EAAGC,OAAQ,MAAS,KAEtGgB,EAAS,IAAIlE,WAAWoB,EAAQF,EAAS,GAE3C0C,EAAM,EACDF,EAAI,EAAGA,EAAIxC,EAAQwC,QACrB,IAAID,EAAI,EAAGA,EAAIrC,EAAOqC,IAAK,KACxBc,EAAaP,EAAIG,IAAIV,EAAGvC,EAASwC,EAAI,EAAG,KAE9CQ,EAAON,KAASU,EAAOH,IAAII,EAAY,EAAG,KAC1CL,EAAON,KAASU,EAAOH,IAAII,EAAY,EAAG,KAC1CL,EAAON,KAASU,EAAOH,IAAII,EAAY,EAAG,KAC1CL,EAAON,KAASK,GAAOA,EAAIE,IAAIV,EAAGvC,EAASwC,EAAI,EAAG,KAAO,EAAI,WAI1DQ,EAGT,SAASM,EAAiBC,MACV,QAAVA,EAAkB,MAAM,IAAIjB,qCAA8BiB,EAAMC,SAAS,MCpG/E,SAASC,EAAiB5E,EAAM+C,OACxB8B,EAAW7E,EAAK8E,SAAS/B,EAAS,IAClCgC,EAAY/E,EAAK8E,SAAS/B,EAAS,OAEvB,IAAdgC,EAAiB,OAAkB,EAAXF,KACV,IAAdE,EAAiB,OAAkB,EAAXF,KACV,IAAdE,EAAiB,OAAkB,EAAXF,KACV,IAAdE,EAAiB,OAAkB,EAAXF,KACV,IAAdE,EAAiB,OAAkB,EAAXF,QAEtB,IAAIpB,MAAM,yBAGlB,SAASuB,EAAUhF,EAAM+C,UAChB/C,EAAKiF,UAAUlC,EAAS,IAAI,GAGrC,SAASmC,EAAWlF,EAAM+C,UACjB/C,EAAKiF,UAAUlC,EAAS,IAAI,GAGrC,MAAiB,SAAoBC,OAC7BhD,EAAO4C,EAAWI,MAEpBhD,EAAKuC,WAAa,QACd,IAAIkB,MAAM,uBAGc,IAA5BzD,EAAK6C,UAAU,GAAG,SACd,IAAIY,MAAM,2BAGZ0B,EAAOnF,EAAK6C,UAAU,GAAG,MAElB,IAATsC,GAAuB,IAATA,QACV,IAAI1B,MAAM,0BAGZvD,EAASF,EAAK6C,UAAU,GAAG,MAE7B7C,EAAKuC,WAAa,EAAK,GAAKrC,QACxB,IAAIuD,MAAM,+BAGX2B,MAAMC,KAAK,CAAEnF,OAAAA,GAAU,SAACoF,EAAGzB,OAC1BxC,EAAQrB,EAAK8E,SAAS,EAAK,GAAKjB,EAAO,GACvC1C,EAASnB,EAAK8E,SAAS,EAAK,GAAKjB,EAAO,GACxCN,EAAOvD,EAAKiF,UAAU,EAAK,GAAKpB,EAAO,GAAG,GAC1Cd,EAAS/C,EAAKiF,UAAU,EAAK,GAAKpB,EAAO,IAAI,GAE7C0B,EAAoB,IAATJ,EAAa,KAAO,CACnCzB,EAAG1D,EAAK6C,UAAU,EAAK,GAAKgB,EAAO,GAAG,GACtCF,EAAG3D,EAAK6C,UAAU,EAAK,GAAKgB,EAAO,GAAG,OAxD5C,SAAgB7D,EAAM+C,UACmB,aAA/B/C,EAAKiF,UAAUlC,EAAS,IAAoD,YAA/B/C,EAAKiF,UAAUlC,EAAS,GA0DvEyC,CAAMxF,EAAM+C,SACP,CACL0C,IAAKb,EAAgB5E,EAAM+C,GAC3BpB,KAAM,IAAI1B,WAAWD,EAAKK,OAAQL,EAAKsC,WAAaS,EAAQQ,GAC5DpC,OAAQ+D,EAAUlF,EAAM+C,GACxBwC,QAAAA,EACAJ,KAAM,MACN9D,MAAO2D,EAAShF,EAAM+C,QAKpB2C,EDoCO,SAAoBhD,OAG/BiD,EACAC,EACAC,EACA3C,EACAoB,2DAPwG,OAA/DjD,MAAOyE,aAAY,QAAG3E,OAAQ4E,aAAa,QAAG/B,KAAAA,gBACrFrC,EAAOiB,EAAWF,GAQpBsB,GACF2B,EAAahE,EAAKsD,UAAU,GAAG,GAC/BW,EAAejE,EAAKsD,UAAU,GAAG,GAAQ,EAAK,EAC9CY,EAAgBlE,EAAKsD,UAAU,GAAG,GAAQ,EAAK,EAC/C/B,EAAavB,EAAKkB,UAAU,IAAI,GAChCyB,EAAa3C,EAAKsD,UAAU,IAAI,KAEhCR,EAAgB9C,EAAKkB,UAAU,GAAG,IAClC8C,EAAa,GAAKhE,EAAKsD,UAAU,IAAI,GACrCW,EAAcjE,EAAKsD,UAAU,IAAI,GACjCY,EAAelE,EAAKsD,UAAU,IAAI,GAClC/B,EAAavB,EAAKkB,UAAU,IAAI,GAChCyB,EAAa3C,EAAKsD,UAAU,IAAI,IAGf,IAAfX,GAAoBpB,GAAc,IACpCoB,EAAc,GAAKpB,OAGf7B,EAAyB,IAAhBuE,EAAoBE,EAAYF,EACzCzE,EAA2B,IAAjB0E,EAAqBE,EAAaF,EAE5CG,EAAa,IAAI/F,WAAW0B,EAAKtB,OAAQsB,EAAKW,WAAaqD,EAAYhE,EAAKY,WAAaoD,GAEzFxB,EAASG,EACXD,EAAiB2B,EAAY,CAAE3E,MAAAA,EAAOF,OAAAA,EAAQ+B,WAAAA,EAAYoB,WAAAA,EAAYN,KAAAA,IACtED,EAAmBiC,EAAY,CAAE3E,MAAAA,EAAOF,OAAAA,EAAQ+B,WAAAA,EAAYc,KAAAA,UAEzD,CAAE3C,MAAAA,EAAOF,OAAAA,EAAQQ,KAAMwC,EAAQjB,WAAAA,GCzExB+C,CADC,IAAIhG,WAAWD,EAAKK,OAAQL,EAAKsC,WAAaS,EAAQQ,GACvC,CAAElC,MAAAA,EAAOF,OAAAA,EAAQ6C,MAAM,UAE5C,CACLyB,IAAKC,EAAIxC,WACTvB,KAAM+D,EAAI/D,KACVR,OAAQuE,EAAIvE,OACZoE,QAAAA,EACAJ,KAAM,MACN9D,MAAOqE,EAAIrE,8QC/ET5B,EAAaC,eAmBAiC,EAAMI,EAAMmE,OACzBC,EAAQC,EAAUzE,GAElB0E,aAAuBrC,UACvBjC,IAAStC,GAA0B,QAAduE,EAAKmB,KACrBmB,OAAOC,OAAO,CAAElG,OAAQ2D,EAAKrC,KAAKtB,OAAOmD,MAAMQ,EAAKrC,KAAKW,WAAY0B,EAAKrC,KAAKW,WAAa0B,EAAKrC,KAAKY,aAAeyB,0BAY9GkC,EAAMrE,OAAOmC,EAAMjC,sBAD5BuE,OAAOC,OAAOvC,EAAM,CACzB3D,SACA8E,KAAMpD,EAAKhC,QAAQ,SAAU,0BAVb,QAAdiE,EAAKmB,cACee,EAAM5F,OAAO0D,EAAKrC,eAAlC6E,GACNF,OAAOC,OAAOvC,EAAM,CAClBrC,KAAM6E,EAAQ7E,KACdwD,KAAM,uDAUe3E,QAAQiG,IAAIN,EAAMO,IAAIL,MCvC3C5G,EAAaC,QAIT,CACViH,MAAAA,EACAC,MAJY,SAACrG,OAAawB,yDAAOtC,SAAaoH,EAAStG,EAAawB,EAAMmE"}